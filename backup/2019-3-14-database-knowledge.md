---
layout: post
title: 知识点整理 - 数据库
date: 2019-03-13 23:00:00
---
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

#### 数据库的基本概念
数据: 描述事物的符号记录，描述事物的符号可以是数字，也可以是文字，图形，音频等，它们都可以通过数字化后存入数据库.  

数据库: 数据库是长期存储在计算机内，有组织的，可共享的大量数据的集合.数据库中的数据按一定的数据模型组织，描述和存储.  

数据库管理系统(DBMS): 位于用户与操作系统之间的一层数据管理软件.数据库管理系统和操作系统一样是计算机的基础软件.  

数据库系统(DBS): 数据库系统是由数据库，数据库管理系统，应用程序和数据库管理员组成的存储，管理，处理和维护数据的系统.  

数据库技术是计算机中发展最快的技术之一，数据库技术的发展是沿着数据模型的主线推进的.  
**数据模型**也是一种模型，它是对现实世界数据特征的抽象.数据模型用于描述数据，组织数据和对数据进行操作.  
数据模型分为两类: 第一类是**概念模型**，第二类是**逻辑模型**和**物理模型**.  
这两类模型应用在开发数据库的不同阶段:  
1.概念模型，又称信息模型，按用户对数据的观点进行建模，用于数据库设计.  
2.第二类中逻辑模型主要包括层次模型，网状模型，关系模型，面向对象数据模型和半结构化模型等.它是用计算机的观点对数据进行建模，
主要用于数据库管理系统的实现.   
第二类中的物理模型是对数据底层的抽象，描述数据在计算机内部的表示和存取方法.

数据库模式: 模式(schema)是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述而不涉及具体的值.  
模式是相对稳定的，模式反映的是数据的结构及其联系.

数据库系统的三级模式:   
1.模式 - 也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述.即它以某种数据模型为基础，将用户的需求统一成为一个逻辑整体.
一个数据库只有一个模式.    
2.外模式 - 又称为子模式或用户模式，外模式通常是模式的子集，是与某一用户相关的数据的逻辑表示.  
3.内模式 - 也称为存储模式，一个数据库只有一个内模式.它是数据结构和存储方式的描述，是数据在数据库内部的组织方式.  

数据库的二级映像: **外模式/模式映像**和**模式/内模式映像**保证了数据库系统中的数据具有较高的逻辑独立性和物理独立性.  

---

**关系型数据库**

域: 一组具有相同数据类型的**值**的集合.  
通过一组域上的笛卡尔积运算，我们可以构建一组关系: D1XD2XD3X...XDn的子集叫做在域D1,D2,D3...Dn上的关系，表示为:
R(D1,D2,D3..Dn)，关系中的每个元素成为关系的元组.     
若关系中的某一属性组能唯一地标识一个元组，而其子集不能，称该属性组为**候选码**.  
候选码的各个属性称为**主属性**，不包含在任何候选码中的属性称为非主属性.  
主码: 若一个关系有多个候选码，则选定其中一个为主码.  

关系的完整性: 关系模型中有三类完整性约束，实体完整性，参照完整性和用户定义的完整性.   
什么是完整性？可以理解为是对关系的某种约束条件，对应于现实世界，体现为对某个实体的约束.如一个人只有一个身份证号，
一个人不能没有名字，一个人的朋友的不能没有名字等等.如果这种约束条件被破坏，显然在现实世界和数据库中都会引发问题.   
实体完整性: 一个关系的主属性不能取空值(NULL).  
参照完整性: 设F是基本关系R的一个或一组属性，但不是R的主码，Ks是基本关系S的主码，若F与Ks对应，则称F是Ks的外码.
称基本关系R为参照关系，基本关系S为被参照关系.  
参照完整性即定义在外码与主码之间的引用规则.即对于R上的每个F，都必须满足:
1.或者取空值(NULL)   2.或者等于S中某个元组的主码值.  
用户定义的完整性: 用户自定义的对于关系中某个属性的限制条件.

视图: 视图是从一个或几个基本表(或视图)中导出的表，它与基本表不同，是一个虚拟表.在数据库中只存放视图的定义，
而不存放视图对应的数据，这些数据仍旧存放在原来的表中.视图就像是一个窗口，透过视图可以看到数据库中数据发生的变化.   

视图有什么作用?  
1.视图可以简化用户操作，使得用户可以将注意力集中在所关心的数据上.   
2.视图对重构数据库提供了一定程度的逻辑独立性.例如，当我们将一个基本表STUDENT(sno,sname,ssex,sage,sdept)垂直分解成为
两张表SX(sno,sname,sage)和SY(sno,ssex,sdept)时，如果重新建立一个视图:
```
CREATE VIEW STUDENT(sno,sname,ssex,sage,sdept)
AS
SELECT SX.sno,SX.sname,SY.ssex,SX.sage,SY.sdept
FROM SX,SY
WHERE SX.sno = SY.sno .
```
这样尽管表发生了变化，但用户程序无需进行修改.  
3.对机密数据提供安全保护.

索引: 建立索引是加快查询速度的有效手段.索引可以快速定位到需要查询的内容.

数据库上的索引有多种类型，包括顺序文件上的索引，B+树上的索引，散列索引和位图索引等.  

顺序文件上的索引指针对按指定的属性值升序或降序存储的关系，在该**属性**上建立一个顺序索引文件.
索引文件由属性值和相应的元组指针组成.

B+树索引是将索引属性组织为B+树的形式，B+树的叶节点为属性值和相应的元组指针，B+树具有动态平衡的优点.
这得益于它的插入和删除方式.
B+树是这样一种树:   
m阶的B+树满足以下条件  
1)每个分支结点最多有m个子树
2)非叶根结点至少有两棵子树，其他每个分支结点至少有R(m/2)(R(X)表示X向上取整)  
3)结点的子树个数与关键字个数相同  
4)所有叶节点包含全部关键字以及指向相应记录的指针，而且在叶节点中按大小顺序排列，并将相邻叶节点按大小顺序
链接起来  
5)所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子节点的指针.  
B+树中有两个指针，一个指向根结点，一个指向最小的叶节点，分别进行多路查找和顺序查找.  
[注]B+树和B树在插入和删除上有些类似，其目的都是为了保证树的高度不会过深. 数据库一般使用B+树进行索引，原因在于
B+树存在指向叶节点(即存放数据的结点)的指针，因此在数据库执行批量查询操作或组操作时可以通过该指针进行访问.想一想如果
用B树该多么麻烦.


索引虽然能够加速数据库查询，但需要占用一定的存储空间.当基本表更新时，索引也需要进行相应地维护，这些都会增加数据库
的负担，因此要根据实际应用的需要有选择地创建索引.

**触发器**: 是用户定义在关系表上的一类由事件驱动的特殊过程.一旦定义，触发器将被保存在数据库服务器中.
任何用户对表的增删改操作均由服务器自动激活相应的触发器，在关系数据库管理系统的核心层进行集中的完整性控制.

触发器又叫做事件-条件-动作规则，当特定的系统事件(如对一个表的增删改操作)发生时，对规则的条件进行检查，
如果条件成立则执行规则中的动作，否则不执行该动作.  
[注]**触发器只能定义在基本表上，不能定义在视图上.**   
触发事件可以是INSERT | DELETE | UPDATE，也可以是这几个事件的组合.还可以定义为UPDATE OF<触发列>，
AFTER/BEFORE是指在事件发生前还是发生后触发.  
触发器按照触发动作的执行间隔可分为行级触发器(FOR EACH ROW)和语句级触发器(FOR EACH STATEMENT).  
建立触发器的SQL语句为:
```
CREATE TRIGGER<触发器名>
{BEFORE | AFTER <触发事件> ON <表名>    /* 指定触发时机 */
REFERENCING NEW|OLD ROW AS<变量>        /* 指出引用的变量 */
FOR EACH{ROW|STATEMENT}        /* 定义触发器的类型 */
[WHEN <触发条件>] <触发动作体>   /* 当触发条件为真时触发动作体 */
```

---

#### 关系数据理论

首先说明一下**数据依赖**的概念: 数据依赖是一个关系内部属性与属性之间的一种约束关系.这种约束关系是通过
属性间值是否相等体现出来的数据间相关联系.它是现实世界属性间相互联系的抽象.    

依赖中最重要的是函数依赖(FD)和多值依赖(MVD)    
**函数依赖**:函数依赖普遍存在于现实生活中，它指的是类似于y = f(x)形式的依赖.即对于任意的x，有一个唯一确定的y值与其对应，如描述一个学生的关系STUDENT(sno,sclass,sname,sdept).
当sno确定下来后，sclass和sdept也随之确定.此时我们说sclass和sdept函数依赖于sno.

**完全函数依赖**:在关系R中，如果X->Y，且对于X的任何真子集，都有X-/>Y，则称Y完全函数依赖于X.
**部分函数依赖**:X->Y，但Y不完全函数依赖于X，称Y对X部分依赖.

数据的函数依赖可能产生一些不好的性质，如: 我们定义一个描述学校教务的数据库U = {sno,sdept,mname,cno,grade}.
包括sno(学号) sdept(系) mname(系主任名字) cno(课程号) grade(课程成绩)
显然存在以下依赖:  
F = {sno -> sdept, sdept->mname, (sno,cno)->grade}  
此时分析这个关系模式，存在以下问题:  
1) 数据冗余:在数据库中出现了大量冗余的mname，这种冗余不是必要的.
2) 更新异常:数据冗余带来了更新上的麻烦，如果系主任变动，必须修改包含该系主任的全部记录.
3) 插入异常:sno作为主属性不能为空，如果没有学生报到，意味着系主任和系也无法插入表中.
4) 删除异常:删除学生信息会破坏系主任和该系的信息.

如何改造这个不好的模式，使之可以消除这些性质，这就是关系规范化的内容.

通常按照属性间的依赖情况来区分关系规范化程度为第一范式，第二范式，第三范式和第四范式，分别记为
1NF，2NF，3NF，4NF，其中3NF被修正后得到BCNF.  
它们之间的关系是: 1NF $$ \supset $$ 2NF $$ \supset $$ 3NF $$ \supset $$ BCNF $$ \supset $$ 4NF

接下来解释各个范式的定义:  
1NF: 每个范式必须是一个不可分的数据项，这是最基本的条件.  

2NF: R $$ \subset $$ 1NF 且每一个非主属性完全函数依赖于任何一个候选码.  
这里对2NF进行解释，非主属性完全函数依赖于任何一个候选码.在上面的例子中，sdept没有完全函数依赖于(sno,cno)，
假如有学生信息(sno,sdept,mname)，由于此时学生未选课，而cno为主属性，所以该信息无法插入.  
如果学生只选了一门课，此时要删除这一门课，由于cno为主属性，则元组也随之一起被删除，学生信息丢失.  
假如学生转系，本身只需要修改sdept以及mname，如果该生选修k门课，则需要同时修改k个元组.  
综上可知，不满足2NF的范式会产生如上问题，解决的方法是将该关系拆成两个满足2NF的关系，在此例中，即:
SC(sno,cno,grade) 和 SL(sno,sdept,mname).  

3NF: 设关系模式R<U,F>∈1NF，若R中不存在码X，属性组Y及非主属性组Z使得X->Y,Y->Z成立，Y-/>X，
则称R<U,F>∈3NF.即每一个非主属性既不传递依赖于码，也不部分依赖于码.

BCNF: 关系模式R<U,F>∈1NF，若X->Y且Y不是X的子集时X必含有码，则R满足3NF.

---

#### 数据库操作
**关系数据库标准语言SQL**   
SQL: 全称为Structured Query Language，结构化查询语言. SQL是关系数据库的标准语言，它通用且功能性极强.   
SQL功能极强且设计巧妙，它有如下几个核心功能:    
 
|:-:|:-:|:-:
| SQL功能 | 动词 |
| 数据查询 | SELECT |
| 数据定义 | CREATE DROP ALTER |
| 数据操纵 | INSERT UPDATE DELETE |
| 数据控制 | GRANT REVOKE | 

**数据定义**  
SQL的数据定义语句如下:    

|:-:|:-:|:-:|:-:|:-:
| 操作对象 | 创建 | 删除 | 修改 | 
| 模式 | CREATE SCHEME | DROP SCHEME | |
| 表 | CREATE TABLE | DROP TABLE | ALTER INDEX |
| 视图 | CREATE VIEW | DROP VIEW | |
| 索引 | CREATE INDEX | DROP INDEX | ALTER INDEX |

SQL标准不提供修改模式和视图定义的操作，用户若想进行修改，必须将其先删除在重新建立.   

1.模式的定义和删除
```sql
CREATE SCHEME <模式名> AUTHORIZATION <用户名>   // <>不需要打出来,[]表示可选
CREATE SCHEME <模式名> AUTHORIZATION <用户名> [<表定义子句>|<视图定义子句>]  // 定义模式的同时可以定义表及视图
DROP SCHEME <模式名><CASCADE|RESTRICT>  // restrict代表在删除模式时，若已经定义了下属对象，则拒绝该删除语句的执行
```
2.基本表的定义、删除和修改
```sql
CREATE TABLE <表名>(<列名><数据类型>[列级完整性约束条件],
<列名><数据类型>[列级完整性约束条件],
<列名><数据类型>[列级完整性约束条件]
...
[表级完整性约束条件]);

ALTER TABLE <表名>
[ADD [COLUMN] <新列名><数据类型>[完整性约束]]
[ADD <表级完整性约束条件>]
[DROP [COLUMN] <列名> [CASCADE|RESTRICT]]
[ALTER COLUMN <列名><数据类型>];

DROP TABLE <表名> [RESTRICT|CASCADE]
```
每一个基本表都属于某一个模式，一个模式包含多个基本表.    
3.索引的建立和删除
```sql
CREATE [UNIQUE][CLUSTER] INDEX <索引名>
ON <表名>(<列名>[次序],<列名>[次序]...) ;

ALTER INDEX <旧索引名> RENAME TO <新索引名> ;

DROP INDEX <索引名> ;
```

**数据查询**   
数据查询是数据库的核心操作，SQL使用SELECT语句进行数据查询，该语句具有灵活的使用方式和丰富的功能.   
```sql
SELECT [ALL|DISTINCT] <目标表达式>,<目标表达式>...   //使用distinct可以去除查询到的重复行
FROM <表名或视图名>,<表名或视图名>...| (SELECT语句)[AS]<别名>
[WHERE <条件表达式>]
[GROUP BY <列名1>[HAVING<条件表达式>]]
[ORDER BY <列名2>[ASC|DESC]] ;
```
如果有`GROUP BY`子句，则将结果按<列名1>的值进行分组，通常在每组中会使用聚集函数.   
而HAVING子句会对组进行限制，只有满足条件的组才予以输出.   
查询的目标表达式不仅可以是一个属性列，还可以是一个表达式.   

常用的查询条件   

|:-:|:-:|:-:
| 查询条件 | 谓词 |
| 比较 | = < > >= <= != <> !> !< NOT+
| 确定范围 | BETWEEN AND , NOT BETWEEN AND |
| 确定集合 | IN , NOT IN |
| 字符匹配 | LIKE , NOT LIKE |
| 空值 | IS NULL , IS NOT NULL |
| 多重条件 | AND , OR , NOT | 

字符匹配   
```
[NOT] LIKE '<匹配串>' [ESCAPE '<换码字符>']
% : 代表任意长度的字符串
_ : 代表任意单个字符
```
[注]数据库字符集为ASCII时一个汉字需要两个_ ; 当字符集为GBK时只需要一个_ .

GROUP BY子句   
对查询结果进行分组的目的是为了细化聚集函数的作用对象，如果不进行分组，聚集函数会作用于整个查询结果.
进行分组后，聚集函数将作用于每一个组，即每一组都有一个函数值.   
聚集函数包括: COUNT SUM AVG MAX MIN .注意COUNT是统计组内元组的个数，而SUM是统计组内某一属性之和.   
[注] WHERE子句是不能用聚集函数作为条件表达式的，比如:
```
SELECT SNO , AVG(GRADE)
FROM SC
WHERE AVG(GRADE) >= 90
GROUP BY SNO   // 查询平均成绩大于等于90的学生信息
```
是错误的.

连接查询  
1. 等值于非等值连接查询 : = 就是等值，<> 就是非等值
2. 自身连接 : 连接操作不仅可以在两个表之间进行，也可以是一个表与其自己进行连接.此时需要为表取两个别名.   
3. 外连接 : 在连接操作中，只有满足条件的元组才会被作为结果输出. 如果希望保留表中的每一个元组的基本情况，
则需要使用外连接，外连接分为左外连接和右外连接，区别是保留左边的表还是右边的表.   
4. 多表连接 : 与两个以上的表进行连接操作.    

嵌套查询    
在SQL语句中，一个`SELECT-FROM-WHERE`称为一个查询块. 将一个查询块嵌套在另一个查询块的WHERE子句中或
HAVING短语的条件中的查询称为**嵌套查询**.    
[注]子查询的SELECT语句不能使用ORDER BY进行排序.   




