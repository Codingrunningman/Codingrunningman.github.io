---
layout: post
title: KMP算法
date: 2019-08-10 00:00:00
---

KMP算法全称为克努特-莫里斯-普拉特算法，由D.E.Knuth, J.H.Morris和V.R.Pratt提出，是一种改进型的字符串匹配算法.

KMP算法在模式串与主串失配后寻找模式串的子串与主串继续匹配，避免了对于主串的回溯，减少了匹配次数，从而提高了匹配效率.

从数据结构课程开始，KMP算法就一直不断被提起，属于非常经典的算法. 对于我自己来说，KMP算法属于看了就懂，但自己写却时常出问题的算法之一.
根本原因是对其匹配过程没有弄清楚，只是浅显地知道它的思想.

#### KMP算法的匹配过程
首先看一下KMP算法的匹配过程:首先有主串S[]和模式串T[]，其中主串为abcabcabda,模式串为abcabd   

 i | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
 S | a | b | c | a | b | c | a | b | d | a   
 T | a | b | c | a | b | d |  |  |  |  |   

为了与数组的下标一致，我们从i=0开始分析.当匹配到i=5时，S[5]与T[5]发生失配，通过观察我们可以看到，
T[0]已经不能和S[0],S[1],S[2]再匹配了，因此S[3]与T[0]比较

 i | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
 S | a | b | c | a | b | c | a | b | d | a   
 T |   |   |   | a | b | c | a | b | d |   |   

此时发现匹配已经完成，显然这种方式比普通匹配的方式减少了匹配次数，原因是我们消除了i=1和i=2时的匹配.  

这时我们提出疑问，如何找到并跳过这些多余的匹配呢？答案是寻找模式串已匹配子串的最长前缀后缀匹配.

#### KMP的算法思路
假设有主串S[]和匹配模式串T[]，用i和j分别表示S和T的下标，两者均从0开始.  
若S[i-j+1...i]与T[0..j-1]匹配，而S[i+1]与T[j]发生了失配，这时我们不必让S[]串回溯到S[i-j+2]处匹配，
而是从i+1处继续匹配，方法是寻找T[0...j-1]的最长前缀子串，我们记为k，使得T[0..k-1]与T[j-k...j-1]可以匹配，
这时我们只需要继续匹配S[i+1]和T[k]即可，避免了S[]的回溯.

就像上面的匹配过程

 i | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
 S | a | b | c | a | b | c | a | b | d | a   
 T |   |   |   | a | b | c | a | b | d |   | 
 
当S[5]和T[5]失配时，我们没有将i回溯至1，再与T[0]进行匹配，而是通过找到了T[]已匹配的子串abcab的最长前缀后缀子串ab,
将S[5]继续与T[2]进行匹配.

同理，当S[i+1]与T[k]再次失败后，我们可以继续去寻找T[k]的最长前缀后缀子串，与S[i+1]继续匹配.直到找不到任何可以匹配的前缀后缀子串为止，
这时可以知道S[0...i]的子串无法再与T[]进行匹配，将S[i+1]与T[0]匹配.

这时我们提出问题，如何找到T[]的最长前缀后缀子串，或者说如何找到失配后T串应该与S[i+1]匹配的位置?

此时我们单独对T[]进行分析，利用数组P[j]来表示当S[i+1]T[j+1]失配时，T[]可以与S[i]匹配位置:

 i | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
 T | a | b | c | a | b | d |   | 
 
1)显然，如果从0开始就失配，没有任何位置可以与S[i+1]匹配，记P[0]为-1.

2)设T[0..P[j]]与T[j-P[j]...j]匹配，此时如果T[P[j]+1]与T[j+1]相等，则显然P[j+1]=P[j]+1;
而如果T[P[j]+1]和T[j+1]不相等，就需要继续寻找T[0...p[j]]的最长前缀后缀匹配，即令T[j]与T[P[P[j]]]匹配，
直到找不到为止.此时将T[j]与T[0]进行比较，若依旧失配，P[j+1]=-1;

寻找P[]的过程也是对T[]的一次匹配过程.

#### KMP的代码实现
实现P[]寻找的代码如下(C语言实现):

```
P[0] = -1;
j = -1;
for(i = 1;i < n;i ++)
{
    while(j >= 0 && T[i] != T[j+1]) j = P[j];
    if(T[i] == T[j+1]) j = j + 1;
    P[i] = j;
}
```

利用P[]进行字符串匹配

```
j = -1;
for(i = 0;i < m;i ++)
{
    while(j >= 0 && S[i] != T[j+1]) j = P[j];
    if(S[i] == T[j+1]) j = j + 1;
    if(j == n - 1)
    {
        // success
        break ;
    }    
}
```

关于KMP的代码，尝试着去理解记忆.

#### 时间复杂度分析
理论上来说，KMP算法可以在线性的时间复杂度内找到匹配字符串的位置.
通过匹配代码可以知道，for循环次数为m，是S[]的长度，而其中夹了一个while循环.
可以知道while循环中的语句只会让j减小，而不会让j增大；让j增大的语句 j = j + 1最多执行m次，
因此在m次for循环里while循环里的语句也最多执行m次，因为j不可能减到-1以下.利用摊还分析可知，在线性时间复杂度内可以完成KMP算法的匹配过程.
 

 