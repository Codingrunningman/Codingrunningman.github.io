---
layout: post
title: 知识点整理 - 数据库
date: 2019-03-13 23:00:00
---
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

#### 数据库的基本概念
数据: 描述事物的符号记录，描述事物的符号可以是数字，也可以是文字，图形，音频等，它们都可以通过数字化后存入数据库.  

数据库: 数据库是长期存储在计算机内，有组织的，可共享的大量数据的集合.数据库中的数据按一定的数据模型组织，描述和存储.  

数据库管理系统(DBMS): 位于用户与操作系统之间的一层数据管理软件.数据库管理系统和操作系统一样是计算机的基础软件.  

数据库系统(DBS): 数据库系统是由数据库，数据库管理系统，应用程序和数据库管理员组成的存储，管理，处理和维护数据的系统.  

数据库技术是计算机中发展最快的技术之一，数据库技术的发展是沿着数据模型的主线推进的.  
**数据模型**也是一种模型，它是对现实世界数据特征的抽象.数据模型用于描述数据，组织数据和对数据进行操作.  
数据模型分为两类: 第一类是**概念模型**，第二类是**逻辑模型**和**物理模型**.  
这两类模型应用在开发数据库的不同阶段:  
1.概念模型，又称信息模型，按用户对数据的观点进行建模，用于数据库设计.  
2.第二类中逻辑模型主要包括层次模型，网状模型，关系模型，面向对象数据模型和半结构化模型等.它是用计算机的观点对数据进行建模，
主要用于数据库管理系统的实现.   
第二类中的物理模型是对数据底层的抽象，描述数据在计算机内部的表示和存取方法.

数据库模式: 模式(schema)是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述而不涉及具体的值.  
模式是相对稳定的，模式反映的是数据的结构及其联系.

数据库系统的三级模式:   
1.模式 - 也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述.即它以某种数据模型为基础，将用户的需求统一成为一个逻辑整体.
一个数据库只有一个模式.
2.外模式 - 又称为子模式或用户模式，外模式通常是模式的子集，是与某一用户相关的数据的逻辑表示.  
3.内模式 - 也称为存储模式，一个数据库只有一个内模式.它是数据结构和存储方式的描述，是数据在数据库内部的组织方式.  

数据库的二级映像: **外模式/模式映像**和**模式/内模式映像**保证了数据库系统中的数据具有较高的逻辑独立性和物理独立性.  

---

**关系型数据库**

域: 一组具有相同数据类型的**值**的集合.  
通过一组域上的笛卡尔积运算，我们可以构建一组关系: D1XD2XD3X...XDn的子集叫做在域D1,D2,D3...Dn上的关系，表示为:
R(D1,D2,D3..Dn)，关系中的每个元素成为关系的元组.     
若关系中的某一属性组能唯一地标识一个元组，而其子集不能，称该属性组为**候选码**.  
候选码的各个属性称为**主属性**，不包含在任何候选码中的属性称为非主属性.  
主码: 若一个关系有多个候选码，则选定其中一个为主码.  

关系的完整性: 关系模型中有三类完整性约束，实体完整性，参照完整性和用户定义的完整性.   
什么是完整性？可以理解为是对关系的某种约束条件，对应于现实世界，体现为对某个实体的约束.如一个人只有一个身份证号，
一个人不能没有名字，一个人的朋友的不能没有名字等等.如果这种约束条件被破坏，显然在现实世界和数据库中都会引发问题.   
实体完整性: 一个关系的主属性不能取空值(NULL).  
参照完整性: 设F是基本关系R的一个或一组属性，但不是R的主码，Ks是基本关系S的主码，若F与Ks对应，则称F是Ks的外码.
称基本关系R为参照关系，基本关系S为被参照关系.  
参照完整性即定义在外码与主码之间的引用规则.即对于R上的每个F，都必须满足:
1.或者取空值(NULL)   2.或者等于S中某个元组的主码值.  
用户定义的完整性: 用户自定义的对于关系中某个属性的限制条件.

视图: 视图是从一个或几个基本表(或视图)中导出的表，它与基本表不同，是一个虚拟表.在数据库中只存放视图的定义，
而不存放视图对应的数据，这些数据仍旧存放在原来的表中.视图就像是一个窗口，透过视图可以看到数据库中数据发生的变化.   

视图有什么作用?  
1.视图可以简化用户操作，使得用户可以将注意力集中在所关心的数据上.   
2.视图对重构数据库提供了一定程度的逻辑独立性.例如，当我们将一个基本表STUDENT(sno,sname,ssex,sage,sdept)垂直分解成为
两张表SX(sno,sname,sage)和SY(sno,ssex,sdept)时，如果重新建立一个视图:
```
CREATE VIEW STUDENT(sno,sname,ssex,sage,sdept)
AS
SELECT SX.sno,SX.sname,SY.ssex,SX.sage,SY.sdept
FROM SX,SY
WHERE SX.sno = SY.sno .
```
这样尽管表发生了变化，但用户程序无需进行修改.  
3.对机密数据提供安全保护.

索引: 建立索引是加快查询速度的有效手段.索引可以快速定位到需要查询的内容.

数据库上的索引有多种类型，包括顺序文件上的索引，B+树上的索引，散列索引和位图索引等.  

顺序文件上的索引指针对按指定的属性值升序或降序存储的关系，在该**属性**上建立一个顺序索引文件.
索引文件由属性值和相应的元组指针组成.

B+树索引是将索引属性组织为B+树的形式，B+树的叶节点为属性值和相应的元组指针，B+树具有动态平衡的优点.
这得益于它的插入和删除方式.
B+树是这样一种树:   
m阶的B+树满足以下条件  
1)每个分支结点最多有m个子树
2)非叶根结点至少有两棵子树，其他每个分支结点至少有R(m/2)(R(X)表示X向上取整)  
3)结点的子树个数与关键字个数相同  
4)所有叶节点包含全部关键字以及指向相应记录的指针，而且在叶节点中按大小顺序排列，并将相邻叶节点按大小顺序
链接起来  
5)所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子节点的指针.  
B+树中有两个指针，一个指向根结点，一个指向最小的叶节点，分别进行多路查找和顺序查找.  

索引虽然能够加速数据库查询，但需要占用一定的存储空间.当基本表更新时，索引也需要进行相应地维护，这些都会增加数据库
的负担，因此要根据实际应用的需要有选择地创建索引.

触发器: 是用户定义在关系表上的一类由事件驱动的特殊过程.一旦定义，触发器将被保存在数据库服务器中.
任何用户对表的增删改操作均由服务器自动激活相应的触发器，在关系数据库管理系统的核心层进行集中的完整性控制.

触发器又叫做事件-条件-动作规则，当特定的系统事件(如对一个表的增删改操作)发生时，对规则的条件进行检查，
如果条件成立则执行规则中的动作，否则不执行该动作.  
[注]**触发器只能定义在基本表上，不能定义在视图上.**   
触发事件可以是INSERT | DELETE | UPDATE，也可以是这几个事件的组合.还可以定义为UPDATE OF<触发列>，
AFTER/BEFORE是指在事件发生前还是发生后触发.  
触发器按照触发动作的执行间隔可分为行级触发器(FOR EACH ROW)和语句级触发器(FOR EACH STATEMENT).  
建立触发器的SQL语句为:
```
CREATE TRIGGER<触发器名>
{BEFORE | AFTER <触发事件> ON <表名>    /* 指定触发时机 */
REFERENCING NEW|OLD ROW AS<变量>        /* 指出引用的变量 */
FOR EACH{ROW|STATEMENT}        /* 定义触发器的类型 */
[WHEN <触发条件>] <触发动作体>   /* 当触发条件为真时触发动作体 */
```

---

#### 关系数据理论

首先说明一下**数据依赖**的概念: 数据依赖是一个关系内部属性与属性之间的一种约束关系.这种约束关系是通过
属性间值是否相等体现出来的数据间相关联系.它是现实世界属性间相互联系的抽象.    

依赖中最重要的是函数依赖(FD)和多值依赖(MVD)    
**函数依赖**:函数依赖普遍存在于现实生活中，它指的是类似于y = f(x)形式的依赖.即对于任意的x，有一个唯一确定的y值与其对应，如描述一个学生的关系STUDENT(sno,sclass,sname,sdept).
当sno确定下来后，sclass和sdept也随之确定.此时我们说sclass和sdept函数依赖于sno.

**完全函数依赖**:在关系R中，如果X->Y，且对于X的任何真子集，都有X-/>Y，则称Y完全函数依赖于X.
**部分函数依赖**:X->Y，但Y不完全函数依赖于X，称Y对X部分依赖.

数据的函数依赖可能产生一些不好的性质，如: 我们定义一个描述学校教务的数据库U = {sno,sdept,mname,cno,grade}.
包括sno(学号) sdept(系) mname(系主任名字) cno(课程号) grade(课程成绩)
显然存在以下依赖:  
F = {sno -> sdept, sdept->mname, (sno,cno)->grade}  
此时分析这个关系模式，存在以下问题:  
1) 数据冗余:在数据库中出现了大量冗余的mname，这种冗余不是必要的.
2) 更新异常:数据冗余带来了更新上的麻烦，如果系主任变动，必须修改包含该系主任的全部记录.
3) 插入异常:sno作为主属性不能为空，如果没有学生报到，意味着系主任和系也无法插入表中.
4) 删除异常:删除学生信息会破坏系主任和该系的信息.

如何改造这个不好的模式，使之可以消除这些性质，这就是关系规范化的内容.

通常按照属性间的依赖情况来区分关系规范化程度为第一范式，第二范式，第三范式和第四范式，分别记为
1NF，2NF，3NF，4NF，其中3NF被修正后得到BCNF.  
它们之间的关系是: 1NF $$ \supset $$ 2NF $$ \supset $$ 3NF $$ \supset $$ BCNF $$ \supset $$ 4NF

接下来解释各个范式的定义:  
1NF: 每个范式必须是一个不可分的数据项，这是最基本的条件.  

2NF: R $$ \subset $$ 1NF 且每一个非主属性完全函数依赖于任何一个候选码.  
这里对2NF进行解释，非主属性完全函数依赖于任何一个候选码.在上面的例子中，sdept没有完全函数依赖于(sno,cno)，
假如有学生信息(sno,sdept,mname)，由于此时学生未选课，而cno为主属性，所以该信息无法插入.  
如果学生只选了一门课，此时要删除这一门课，由于cno为主属性，则元组也随之一起被删除，学生信息丢失.  
假如学生转系，本身只需要修改sdept以及mname，如果该生选修k门课，则需要同时修改k个元组.  
综上可知，不满足2NF的范式会产生如上问题，解决的方法是将该关系拆成两个满足2NF的关系，在此例中，即:
SC(sno,cno,grade) 和 SL(sno,sdept,mname).  

3NF: 设关系模式R<U,F>∈1NF，若R中不存在码X，属性组Y及非主属性组Z使得X->Y,Y->Z成立，Y-/>X，
则称R<U,F>∈3NF.即每一个非主属性既不传递依赖于码，也不部分依赖于码.

BCNF: 关系模式R<U,F>∈1NF，若X->Y且Y不是X的子集时X必含有码，则R满足3NF.








